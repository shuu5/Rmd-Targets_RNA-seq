---
title: "RNA-seq解析: DEG解析 (edgeR) (実験ID: `r params$experiment_id`)"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
params:
  experiment_id: "default_id"
  # 入力ファイル/オブジェクト
  input_se: NULL  # 前段階のSummarizedExperimentオブジェクト
  # 出力設定
  output_dir: ""  # 結果出力ディレクトリ
  plot_dir: ""    # プロット出力ディレクトリ
  table_dir: ""   # テーブル出力ディレクトリ
  # フィルタリングパラメータ
  filter_columns: !r list()  # フィルタリングに使用するcolData列と値のリスト（例: list(target_gene = "IFITM3", assay = "knockdown")）
  target_gene: ""  # 後方互換性のため維持（非推奨）
  assay: ""        # 後方互換性のため維持（非推奨）
  # DEG解析パラメータ
  control: ""      # コントロール条件（例: "scramble"）
  targets: !r c()  # ターゲット条件（例: c("sh1", "sh2")）
  condition_column: "condition"  # 条件を格納している列名
  housekeeping_gene_set: "standard"  # "standard" または "alternative"
  fdr_threshold: 0.05  # FDRの閾値
  log2fc_threshold: 1  # log2 fold changeの閾値
---

```{r setup, include=FALSE}
# このチャンクはRmdファイルが読み込まれた時に最初に実行され、必要なパッケージの読み込みと設定を行う
library(futile.logger)
library(SummarizedExperiment)
library(edgeR)
library(limma)
library(here)
library(fs)
library(ggplot2)
library(dplyr)
library(tibble)
library(knitr)
library(kableExtra)
library(DT)
library(ggrepel)

# utility関数を読み込む
source(here("R", "utility.R"))

# ログ設定
# utility.Rで定義したsetup_logger関数を使用
module_name <- "deg_edgeR"
logger_settings <- setup_logger(params$experiment_id, module_name)
flog.appender(logger_settings$appender)
flog.layout(logger_settings$layout)
flog.threshold(logger_settings$threshold)

# knitrオプションを設定 - メッセージと警告を表示しない
knitr::opts_chunk$set(
  message = FALSE, 
  warning = FALSE, 
  fig.width = 10,
  fig.height = 6,
  dpi = 300
)

# タイムスタンプの一貫性のためにタイムゾーンを統一
Sys.setenv(TZ = "Asia/Tokyo")

# グラフのテーマ設定
theme_set(theme_classic() + 
            theme(plot.title = element_text(hjust = 0.5)))

# 既存のオブジェクトをクリーンアップ（paramsは保持）
rm(list = setdiff(ls(), c("params")))

flog.info("--- セットアップ：R Markdownドキュメントを実行開始 ---")
flog.info("パラメータ情報: experiment_id = %s", params$experiment_id)
flog.debug("出力ディレクトリ: %s", params$output_dir)
flog.debug("プロットディレクトリ: %s", params$plot_dir)
flog.debug("テーブルディレクトリ: %s", params$table_dir)
flog.debug("フィルタリング列: %s", paste(names(params$filter_columns), collapse = ", "))
flog.debug("フィルタリング値: %s", paste(unlist(params$filter_columns), collapse = ", "))
flog.debug("ターゲット遺伝子: %s", params$target_gene)
flog.debug("アッセイタイプ: %s", params$assay)
flog.debug("コントロール条件: %s", params$control)
flog.debug("ターゲット条件: %s", paste(params$targets, collapse = ", "))
flog.debug("条件列: %s", params$condition_column)
flog.debug("ハウスキーピング遺伝子セット: %s", params$housekeeping_gene_set)
flog.debug("FDR閾値: %s", params$fdr_threshold)
flog.debug("Log2FC閾値: %s", params$log2fc_threshold)
flog.info("セットアップ完了")
```

```{r check_input, include=FALSE}
flog.info("--- 入力データの確認開始 ---")

# 入力SEオブジェクトの存在確認と基本チェック
if (is.null(params$input_se)) {
  msg <- "入力SEオブジェクトがNULLです"
  flog.error(msg)
  stop(msg)
} else {
  # SEオブジェクトのクラスと次元を確認
  if (!inherits(params$input_se, "SummarizedExperiment")) {
    msg <- "入力オブジェクトはSummarizedExperimentではありません"
    flog.error(msg)
    stop(msg)
  }
  
  flog.info("入力SEオブジェクトを確認: %d フィーチャー, %d サンプル", 
            nrow(params$input_se), ncol(params$input_se))
  flog.debug("入力SEオブジェクトの基本情報:")
  flog.debug("- assay名: %s", paste(assayNames(params$input_se), collapse=", "))
  flog.debug("- rowData列: %s", paste(colnames(rowData(params$input_se)), collapse=", "))
  flog.debug("- colData列: %s", paste(colnames(colData(params$input_se)), collapse=", "))
  flog.debug("- metadata: %s", paste(names(metadata(params$input_se)), collapse=", "))
}

# フィルタリングパラメータの設定（後方互換性のため）
# paramsを直接変更することはできないため、ローカル変数を使用
filter_columns <- params$filter_columns
if (length(filter_columns) == 0 && params$target_gene != "" && params$assay != "") {
  flog.info("filter_columnsが空のため、従来のtarget_geneとassayパラメータを使用します。")
  filter_columns <- list(target_gene = params$target_gene, assay = params$assay)
}

# 必須パラメータのチェック
if (length(filter_columns) == 0) {
  msg <- "フィルタリング条件が指定されていません。filter_columnsまたはtarget_gene/assayを指定してください。"
  flog.error(msg)
  stop(msg)
}

# フィルタリング列が存在するか確認
for (col_name in names(filter_columns)) {
  if (!col_name %in% colnames(colData(params$input_se))) {
    msg <- sprintf("フィルタリング用の列 '%s' がcolDataに存在しません", col_name)
    flog.error(msg)
    stop(msg)
  }
}

if (params$control == "") {
  msg <- "コントロール条件が指定されていません"
  flog.error(msg)
  stop(msg)
}

if (length(params$targets) == 0) {
  msg <- "ターゲット条件が指定されていません"
  flog.error(msg)
  stop(msg)
}

if (!params$condition_column %in% colnames(colData(params$input_se))) {
  msg <- sprintf("指定された条件列 '%s' がcolDataに存在しません", params$condition_column)
  flog.error(msg)
  stop(msg)
}

# 出力ディレクトリの確認と作成
if (!is.null(params$plot_dir) && params$plot_dir != "") {
  if (!fs::dir_exists(params$plot_dir)) {
    flog.info("プロットディレクトリを作成します: %s", params$plot_dir)
    fs::dir_create(params$plot_dir, recursive = TRUE)
  }
}

if (!is.null(params$table_dir) && params$table_dir != "") {
  if (!fs::dir_exists(params$table_dir)) {
    flog.info("テーブルディレクトリを作成します: %s", params$table_dir)
    fs::dir_create(params$table_dir, recursive = TRUE)
  }
}

flog.info("--- 入力データの確認完了 ---")
```

# 1. はじめに

このレポートでは、edgeRパッケージを使用して発現差異解析（DEG解析）を実行します。この解析では、以下のパラメータに基づいてDEG解析を実行します：

- **フィルタリング**: `r paste(names(filter_columns), "=", unlist(filter_columns), collapse = ", ")`
- **ターゲット遺伝子**: `r params$target_gene`
- **アッセイタイプ**: `r params$assay`
- **コントロール条件**: `r params$control`
- **ターゲット条件**: `r paste(params$targets, collapse = ", ")`
- **使用するハウスキーピング遺伝子セット**: `r params$housekeeping_gene_set`
- **FDR閾値**: `r params$fdr_threshold`
- **Log2FC閾値**: `r params$log2fc_threshold`

```{r filter_samples, include=FALSE}
flog.info("--- サンプルフィルタリング開始 ---")

# 入力SEオブジェクトをコピー
se <- params$input_se

# colDataを抽出
col_data <- as.data.frame(colData(se))

# フィルタリング条件を適用
flog.debug("フィルタリング条件: %s", paste(names(filter_columns), "=", unlist(filter_columns), collapse = ", "))

# 初期化（すべてのサンプルを選択）
filtered_idx <- rep(TRUE, ncol(se))

# 各フィルタリング条件を適用
for (col_name in names(filter_columns)) {
  col_value <- filter_columns[[col_name]]
  # カラムの型に応じたフィルタリング（文字列、数値、論理値など）
  if (is.character(col_value)) {
    # 文字列の場合
    filtered_idx <- filtered_idx & (col_data[[col_name]] == col_value)
  } else if (is.numeric(col_value)) {
    # 数値の場合
    filtered_idx <- filtered_idx & (col_data[[col_name]] == col_value)
  } else if (is.logical(col_value)) {
    # 論理値の場合
    filtered_idx <- filtered_idx & (col_data[[col_name]] == col_value)
  } else if (is.factor(col_value)) {
    # ファクターの場合
    filtered_idx <- filtered_idx & (col_data[[col_name]] == as.character(col_value))
  } else {
    # その他の型の場合（as.characterでの比較を試みる）
    filtered_idx <- filtered_idx & (col_data[[col_name]] == as.character(col_value))
  }
  flog.debug("列 '%s' = '%s' でフィルタリング後のサンプル数: %d", col_name, col_value, sum(filtered_idx))
}

# フィルタリング結果を確認
flog.info("フィルタリング前のサンプル数: %d", ncol(se))
flog.info("フィルタリング後のサンプル数: %d", sum(filtered_idx))

if (sum(filtered_idx) == 0) {
  msg <- sprintf("条件に一致するサンプルがありません（%s）", paste(names(filter_columns), "=", unlist(filter_columns), collapse = ", "))
  flog.error(msg)
  stop(msg)
}

# SEオブジェクトをフィルタリング
se <- se[, filtered_idx]

# フィルタリング後のサンプル情報をログに記録
sample_info <- data.frame(
  sample_id = colnames(se),
  condition = colData(se)[[params$condition_column]],
  replicate = colData(se)$replicate
)
flog.debug("フィルタリング後のサンプル情報:")
for (i in seq_len(nrow(sample_info))) {
  flog.debug("- %s: condition=%s, replicate=%s", 
             sample_info$sample_id[i], 
             sample_info$condition[i],
             sample_info$replicate[i])
}

# コントロールとターゲット条件の存在を確認
control_samples <- colData(se)[[params$condition_column]] == params$control
if (sum(control_samples) == 0) {
  msg <- sprintf("コントロール条件 '%s' に一致するサンプルがありません", params$control)
  flog.error(msg)
  stop(msg)
}

# 存在するターゲット条件だけを使用するための調整
available_targets <- c()
for (target in params$targets) {
  target_samples <- colData(se)[[params$condition_column]] == target
  if (sum(target_samples) == 0) {
    flog.warn("ターゲット条件 '%s' に一致するサンプルがありません。このターゲットはスキップします。", target)
  } else {
    available_targets <- c(available_targets, target)
  }
}

# 使用可能なターゲットがない場合はエラー
if (length(available_targets) == 0) {
  msg <- sprintf("使用可能なターゲット条件がありません（指定されたターゲット: %s）", paste(params$targets, collapse = ", "))
  flog.error(msg)
  stop(msg)
}

# 使用可能なターゲットのみを使用するよう設定
active_targets <- available_targets
if (length(active_targets) < length(params$targets)) {
  flog.info("使用可能なターゲット条件のみを使用します: %s", paste(active_targets, collapse = ", "))
}

flog.info("--- サンプルフィルタリング完了 ---")
```

# 2. サンプル情報

DEG解析に使用するサンプルは以下の通りです：

```{r display_sample_info}
# フィルタリング後のサンプル情報を表示
sample_info <- data.frame(
  Sample = colnames(se),
  Condition = colData(se)[[params$condition_column]],
  Replicate = colData(se)$replicate
)

kable(sample_info, caption = "DEG解析に使用するサンプル一覧") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 12)
```

```{r check_replicates, include=FALSE}
flog.info("--- レプリケート確認開始 ---")

# サンプルグループごとにレプリケート数を確認
conditions <- unique(colData(se)[[params$condition_column]])
has_replicates <- TRUE

for (cond in conditions) {
  cond_samples <- colData(se)[[params$condition_column]] == cond
  cond_replicates <- length(unique(colData(se)$replicate[cond_samples]))
  flog.debug("条件 '%s' のレプリケート数: %d", cond, cond_replicates)
  
  if (sum(cond_samples) <= 1 || cond_replicates <= 1) {
    has_replicates <- FALSE
    flog.info("条件 '%s' にはレプリケートがありません", cond)
  }
}

flog.info("レプリケートの有無: %s", ifelse(has_replicates, "あり", "なし"))
flog.info("--- レプリケート確認完了 ---")
```

```{r prepare_deg_analysis, include=FALSE}
flog.info("--- DEG解析準備開始 ---")

# カウントデータを取得
counts <- assay(se, "counts")

# ハウスキーピング遺伝子セットを定義
standard_hk_genes <- c("GAPDH", "ACTB", "HPRT1", "B2M", "18S rRNA", "GUSB", "HMBS", "UBC", "TBP", "RPL13A")
alternative_hk_genes <- c("RPL27", "RPL4", "RPS29", "OAZ1", "SRP14", "TMBIM6", "RPL36AL", "MORF4L2", "SLC25A3", "ANKRD27")

# 使用するハウスキーピング遺伝子を選択
if (params$housekeeping_gene_set == "standard") {
  hk_genes <- standard_hk_genes
  flog.info("標準的なハウスキーピング遺伝子セットを使用します")
} else if (params$housekeeping_gene_set == "alternative") {
  hk_genes <- alternative_hk_genes
  flog.info("代替ハウスキーピング遺伝子セットを使用します")
} else {
  msg <- sprintf("不明なハウスキーピング遺伝子セット '%s'", params$housekeeping_gene_set)
  flog.error(msg)
  stop(msg)
}

# ハウスキーピング遺伝子の存在を確認
hk_genes_found <- intersect(hk_genes, rownames(counts))
if (length(hk_genes_found) == 0) {
  flog.warn("指定されたハウスキーピング遺伝子が見つかりません")
  flog.info("ハウスキーピング遺伝子の検出にgene_nameカラムも確認します")
  
  # rowDataにgene_nameがある場合は確認
  if ("gene_name" %in% colnames(rowData(se))) {
    gene_name_map <- rowData(se)$gene_name
    names(gene_name_map) <- rownames(se)
    
    hk_genes_found <- names(gene_name_map)[gene_name_map %in% hk_genes]
    flog.info("gene_name列から見つかったハウスキーピング遺伝子: %s", 
             paste(hk_genes_found, collapse = ", "))
  }
  
  if (length(hk_genes_found) == 0) {
    flog.warn("ハウスキーピング遺伝子が見つかりません。Common dispersion推定が必要な場合は問題になります。")
  }
}

flog.info("見つかったハウスキーピング遺伝子: %s (%d/%d)", 
         paste(hk_genes_found, collapse = ", "), 
         length(hk_genes_found), 
         length(hk_genes))

# グループ情報を準備
group <- factor(colData(se)[[params$condition_column]])
flog.debug("サンプルグループ: %s", paste(group, collapse = ", "))

# DGEListオブジェクトを作成
flog.debug("DGEListオブジェクトを作成")
dge <- DGEList(counts = counts, group = group)

# ライブラリサイズの正規化
flog.debug("ライブラリサイズを正規化（TMM法）")
dge <- calcNormFactors(dge, method = "TMM")

flog.info("--- DEG解析準備完了 ---")
```

# 3. 差異発現解析（DEG解析）

## 3.1 DEG解析アプローチ

この解析では、以下の方法でDEG解析を実行します：

- **使用するパッケージ**: edgeR
- **正規化方法**: TMM法（Trimmed Mean of M-values）
- **レプリケート**: `r ifelse(has_replicates, "あり（生物学的レプリケートを利用した分散推定を実行）", "なし（ハウスキーピング遺伝子を使用した共通分散を推定）")`

```{r deg_analysis, include=FALSE}
flog.info("--- DEG解析実行開始 ---")

# DEG結果を格納するリスト
deg_results <- list()
metadata(se)$deg_results <- list()

# レプリケートの有無に応じて異なる解析を実行
if (has_replicates) {
  flog.info("レプリケートがあるため、生物学的レプリケートを用いた分散を推定します")
  
  # デザイン行列を作成
  flog.debug("デザイン行列を作成")
  design <- model.matrix(~ 0 + group)
  colnames(design) <- levels(group)
  
  # 分散を推定
  flog.debug("分散を推定")
  dge <- estimateDisp(dge, design, robust = TRUE)
  
  flog.debug("推定されたcommon dispersion: %f", dge$common.dispersion)
  flog.debug("BCV: %f", sqrt(dge$common.dispersion))
  
  # 各ターゲットとコントロールの比較を実行
  for (target in active_targets) {
    flog.info("DEG解析実行: %s vs %s", target, params$control)
    
    # 比較対象のサンプルを抽出
    comp_samples <- colData(se)[[params$condition_column]] %in% c(target, params$control)
    if (sum(comp_samples) < 2) {
      flog.error("比較対象のサンプルが不足しています: %s vs %s", target, params$control)
      next
    }
    
    # 比較用のグループ情報を作成
    comp_groups <- c(params$control, target)
    comp_group <- factor(colData(se)[[params$condition_column]][comp_samples], levels = comp_groups)
    comp_dge <- dge[, comp_samples]
    comp_dge$samples$group <- comp_group
    
    # exactTestを実行
    et <- exactTest(comp_dge)
    
    # 結果を取得
    res <- topTags(et, n = Inf)$table
    res$FDR <- p.adjust(res$PValue, method = "BH")
    res$significant <- res$FDR < params$fdr_threshold & abs(res$logFC) > params$log2fc_threshold
    
    # 結果をリストに追加
    comparison_name <- paste0(target, "_vs_", params$control)
    deg_results[[comparison_name]] <- res
    metadata(se)$deg_results[[comparison_name]] <- res
    
    # DEGの数をカウント
    n_up <- sum(res$FDR < params$fdr_threshold & res$logFC > params$log2fc_threshold)
    n_down <- sum(res$FDR < params$fdr_threshold & res$logFC < -params$log2fc_threshold)
    flog.info("DEG数 (%s vs %s): 上昇=%d, 減少=%d", target, params$control, n_up, n_down)
  }
} else {
  flog.info("レプリケートがないため、ハウスキーピング遺伝子を使用して共通分散を推定します")
  
  if (length(hk_genes_found) == 0) {
    flog.warn("ハウスキーピング遺伝子が見つからないため、デフォルトの分散値を使用します")
    common_disp <- 0.4  # デフォルト値
  } else {
    # ハウスキーピング遺伝子のCVを計算
    hk_counts <- dge$counts[hk_genes_found, , drop = FALSE]
    hk_norm_counts <- t(t(hk_counts) / dge$samples$norm.factors)
    hk_cv <- apply(hk_norm_counts, 1, function(x) sd(x) / mean(x))
    common_disp <- median(hk_cv^2)
    
    flog.info("ハウスキーピング遺伝子から推定された共通分散: %f", common_disp)
  }
  
  # 推定された共通分散を設定
  dge$common.dispersion <- common_disp
  metadata(se)$common_dispersion <- common_disp
  
  # 各ターゲットとコントロールの比較を実行
  for (target in active_targets) {
    flog.info("DEG解析実行: %s vs %s", target, params$control)
    
    # 比較対象のサンプルを抽出
    comp_samples <- colData(se)[[params$condition_column]] %in% c(target, params$control)
    if (sum(comp_samples) < 2) {
      flog.error("比較対象のサンプルが不足しています: %s vs %s", target, params$control)
      next
    }
    
    # 比較用のグループ情報を作成
    comp_groups <- c(params$control, target)
    comp_group <- factor(colData(se)[[params$condition_column]][comp_samples], levels = comp_groups)
    comp_dge <- dge[, comp_samples]
    comp_dge$samples$group <- comp_group
    
    # exactTestを実行
    et <- exactTest(comp_dge, dispersion = common_disp)
    
    # 結果を取得
    res <- topTags(et, n = Inf)$table
    res$FDR <- p.adjust(res$PValue, method = "BH")
    res$significant <- res$FDR < params$fdr_threshold & abs(res$logFC) > params$log2fc_threshold
    
    # 結果をリストに追加
    comparison_name <- paste0(target, "_vs_", params$control)
    deg_results[[comparison_name]] <- res
    metadata(se)$deg_results[[comparison_name]] <- res
    
    # DEGの数をカウント
    n_up <- sum(res$FDR < params$fdr_threshold & res$logFC > params$log2fc_threshold)
    n_down <- sum(res$FDR < params$fdr_threshold & res$logFC < -params$log2fc_threshold)
    flog.info("DEG数 (%s vs %s): 上昇=%d, 減少=%d", target, params$control, n_up, n_down)
  }
}

flog.info("--- DEG解析実行完了 ---")
```

## 3.2 DEG解析結果の概要

以下に各比較のDEG解析結果の概要を示します：

```{r deg_summary}
# 結果概要をデータフレームとして整理
summary_df <- data.frame(
  比較 = character(),
  上昇DEG数 = integer(),
  減少DEG数 = integer(),
  総DEG数 = integer(),
  stringsAsFactors = FALSE
)

for (comparison in names(deg_results)) {
  res <- deg_results[[comparison]]
  n_up <- sum(res$FDR < params$fdr_threshold & res$logFC > params$log2fc_threshold)
  n_down <- sum(res$FDR < params$fdr_threshold & res$logFC < -params$log2fc_threshold)
  n_total <- n_up + n_down
  
  summary_df <- rbind(summary_df, data.frame(
    比較 = comparison,
    上昇DEG数 = n_up,
    減少DEG数 = n_down,
    総DEG数 = n_total,
    stringsAsFactors = FALSE
  ))
}

kable(summary_df, caption = paste0("DEG解析結果の概要 (FDR < ", params$fdr_threshold, 
                                 ", |log2FC| > ", params$log2fc_threshold, ")")) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 12)
```

```{r create_plots, include=FALSE}
flog.info("--- 可視化プロット作成開始 ---")

# gene_name情報を取得
has_gene_name <- "gene_name" %in% colnames(rowData(se))
gene_names <- NULL
if (has_gene_name) {
  gene_names <- rowData(se)$gene_name
  names(gene_names) <- rownames(se)
  flog.info("gene_name情報を使用します")
} else {
  flog.warn("gene_name情報が見つかりません。プロットにはEnsembl IDが使用されます")
}

# MAプロットとVolcanoプロットを作成する関数
create_ma_plot <- function(res, title, threshold = params$fdr_threshold, fc_threshold = params$log2fc_threshold) {
  # 遺伝子名を追加
  plot_data <- as.data.frame(res)
  if (has_gene_name) {
    plot_data$gene_name <- gene_names[rownames(plot_data)]
  } else {
    plot_data$gene_name <- rownames(plot_data)
  }
  
  # 有意な遺伝子かどうかのフラグ
  plot_data$sig <- plot_data$FDR < threshold & abs(plot_data$logFC) > fc_threshold
  
  # ラベル付けする上位遺伝子を選択（上位10遺伝子）
  top_genes <- plot_data[plot_data$sig, ]
  top_genes <- top_genes[order(top_genes$FDR), ]
  top_genes <- head(top_genes, 10)
  
  p <- ggplot(plot_data, aes(x = logCPM, y = logFC)) +
    geom_point(aes(color = sig), alpha = 0.5) +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "grey50")) +
    geom_hline(yintercept = 0, linetype = "dashed") +
    geom_hline(yintercept = fc_threshold, linetype = "dotted") +
    geom_hline(yintercept = -fc_threshold, linetype = "dotted") +
    labs(title = title,
         x = "Log2 CPM",
         y = "Log2 Fold Change") +
    theme(legend.position = "none")
  
  # 上位遺伝子にラベルを追加
  if (nrow(top_genes) > 0) {
    p <- p + geom_text_repel(
      data = top_genes,
      aes(label = gene_name),
      box.padding = 0.5,
      max.overlaps = 20,
      size = 3
    )
  }
  
  return(p)
}

create_volcano_plot <- function(res, title, threshold = params$fdr_threshold, fc_threshold = params$log2fc_threshold) {
  # 遺伝子名を追加
  plot_data <- as.data.frame(res)
  if (has_gene_name) {
    plot_data$gene_name <- gene_names[rownames(plot_data)]
  } else {
    plot_data$gene_name <- rownames(plot_data)
  }
  
  # 有意性の種類を設定
  plot_data$sig_type <- "Not Significant"
  plot_data$sig_type[plot_data$FDR < threshold & plot_data$logFC > fc_threshold] <- "Up-regulated"
  plot_data$sig_type[plot_data$FDR < threshold & plot_data$logFC < -fc_threshold] <- "Down-regulated"
  
  # ラベル付けする上位遺伝子を選択（上位10遺伝子）
  sig_genes <- plot_data[plot_data$sig_type != "Not Significant", ]
  top_genes <- sig_genes[order(sig_genes$FDR), ]
  top_genes <- head(top_genes, 10)
  
  p <- ggplot(plot_data, aes(x = logFC, y = -log10(FDR))) +
    geom_point(aes(color = sig_type), alpha = 0.5) +
    scale_color_manual(values = c(
      "Up-regulated" = "red",
      "Down-regulated" = "blue",
      "Not Significant" = "grey50"
    )) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    geom_vline(xintercept = fc_threshold, linetype = "dotted") +
    geom_vline(xintercept = -fc_threshold, linetype = "dotted") +
    geom_hline(yintercept = -log10(threshold), linetype = "dotted") +
    labs(title = title,
         x = "Log2 Fold Change",
         y = "-Log10 FDR",
         color = "Significance") +
    theme(legend.position = "bottom")
  
  # 上位遺伝子にラベルを追加
  if (nrow(top_genes) > 0) {
    p <- p + geom_text_repel(
      data = top_genes,
      aes(label = gene_name),
      box.padding = 0.5,
      max.overlaps = 20,
      size = 3
    )
  }
  
  return(p)
}

# 各比較のプロットを作成して保存
all_ma_plots <- list()
all_volcano_plots <- list()

for (comparison in names(deg_results)) {
  flog.debug("プロット作成: %s", comparison)
  res <- deg_results[[comparison]]
  
  # MAプロット
  ma_plot <- create_ma_plot(res, paste0("MA Plot: ", comparison))
  all_ma_plots[[comparison]] <- ma_plot
  
  # Volcanoプロット
  volcano_plot <- create_volcano_plot(res, paste0("Volcano Plot: ", comparison))
  all_volcano_plots[[comparison]] <- volcano_plot
  
  # プロットを保存
  if (!is.null(params$plot_dir) && params$plot_dir != "") {
    ma_plot_path <- fs::path(params$plot_dir, paste0("ma_plot_", comparison, ".png"))
    volcano_plot_path <- fs::path(params$plot_dir, paste0("volcano_plot_", comparison, ".png"))
    
    flog.debug("MAプロット保存: %s", ma_plot_path)
    ggsave(
      filename = ma_plot_path,
      plot = ma_plot,
      width = 10,
      height = 6,
      dpi = 300
    )
    
    flog.debug("Volcanoプロット保存: %s", volcano_plot_path)
    ggsave(
      filename = volcano_plot_path,
      plot = volcano_plot,
      width = 10,
      height = 6,
      dpi = 300
    )
  }
}

flog.info("--- 可視化プロット作成完了 ---")
```

```{r save_deg_results, include=FALSE}
flog.info("--- DEG結果保存開始 ---")

# 各比較のDEG結果をCSVとして保存
for (comparison in names(deg_results)) {
  if (!is.null(params$table_dir) && params$table_dir != "") {
    # 結果データフレーム
    result_df <- as.data.frame(deg_results[[comparison]])
    
    # gene_name情報を追加
    if ("gene_name" %in% colnames(rowData(se))) {
      # gene_nameをエンスンブルIDの右隣に挿入
      gene_names_for_result <- rowData(se)[rownames(result_df), "gene_name"]
      
      # 列の順序を整理（gene_nameを先頭に）
      result_df <- cbind(
        gene_name = gene_names_for_result,
        result_df
      )
      
      flog.debug("DEG結果に gene_name 列を追加しました")
    }
    
    # CSVとして保存
    file_path <- fs::path(params$table_dir, paste0("deg_", comparison, ".csv"))
    flog.debug("DEG結果保存: %s", file_path)
    write.csv(result_df, file = file_path, row.names = TRUE)
  }
}

flog.info("--- DEG結果保存完了 ---")
```

## 3.3 MAプロットとVolcanoプロット

各比較のMAプロットとVolcanoプロットを表示します。

```{r display_plots, fig.height=7, fig.width=11}
# 各比較のMAプロットとVolcanoプロットを表示
for (comparison in names(deg_results)) {
  cat(paste0("\n### ", comparison, "\n\n"))
  
  # MAプロット
  print(all_ma_plots[[comparison]])
  
  # Volcanoプロット
  print(all_volcano_plots[[comparison]])
  
  cat("\n")
}
```

## 3.4 上位DEG一覧

各比較の上位DEGを表示します：

```{r top_degs}
# 各比較の上位DEGを表示
for (comparison in names(deg_results)) {
  cat(paste0("\n### ", comparison, " の上位DEG (上位10件)\n\n"))
  
  # 上位DEG
  res <- deg_results[[comparison]]
  top_degs <- res[order(res$FDR), ][1:min(10, nrow(res)), ]
  
  # gene_nameカラムがあれば表示に加える
  if ("gene_name" %in% colnames(rowData(se))) {
    # 既存のtop_degsデータフレームにgene_name列を追加
    top_degs$gene_name <- rowData(se)[rownames(top_degs), "gene_name"]
    # 列の順序を調整（gene_nameを最初に）
    top_degs <- top_degs[, c("gene_name", "logFC", "logCPM", "PValue", "FDR", "significant")]
  } else {
    top_degs <- top_degs[, c("logFC", "logCPM", "PValue", "FDR", "significant")]
  }
  
  print(kable(top_degs, caption = paste0(comparison, " の上位DEG")) %>%
          kable_styling(bootstrap_options = c("striped", "hover", "condensed"), font_size = 12))
  
  cat("\n")
}
```

```{r record_history, include=FALSE}
flog.info("--- パイプライン履歴記録開始 ---")

# モジュール名を設定
module_name <- "deg_edgeR"

# SEオブジェクトのメタデータに処理履歴を記録
se <- record_pipeline_history(
  se = se,
  module_name = module_name,
  description = "edgeRを使用したDEG解析",
  parameters = list(
    experiment_id = params$experiment_id,
    filter_columns = filter_columns,
    target_gene = params$target_gene,
    assay = params$assay,
    control = params$control,
    targets = active_targets,
    condition_column = params$condition_column,
    housekeeping_gene_set = params$housekeeping_gene_set,
    fdr_threshold = params$fdr_threshold,
    log2fc_threshold = params$log2fc_threshold,
    has_replicates = has_replicates
  )
)

flog.info("パイプライン履歴を記録しました: pipeline_history$%s", module_name)
flog.info("--- パイプライン履歴記録完了 ---")
```

# 4. まとめ

このモジュールでは、edgeRパッケージを使用して発現差異解析を実行しました。以下のポイントが重要です：

- **フィルタリング**: `r paste(names(filter_columns), "=", unlist(filter_columns), collapse = ", ")`
- **ターゲット遺伝子**: `r params$target_gene`
- **アッセイタイプ**: `r params$assay`
- **コントロール条件**: `r params$control`
- **ターゲット条件**: `r paste(params$targets, collapse = ", ")`
- **レプリケート**: `r ifelse(has_replicates, "生物学的レプリケートを使用して分散を推定", "ハウスキーピング遺伝子を使用して共通分散を推定")`しました。
`r if(!has_replicates) paste0("- **共通分散**: ", round(metadata(se)$common_dispersion, 4), " (CV: ", round(sqrt(metadata(se)$common_dispersion), 4), ")")` 
- **結果**: 各比較において、FDR < `r params$fdr_threshold`かつ|log2FC| > `r params$log2fc_threshold`の基準でDEGを特定しました。

```{r session_info}
# セッション情報の表示（パイプラインの再現性のため）
sessionInfo()
```

```{r return_se, echo=FALSE, include=FALSE}
# targetsパッケージで使用するための戻り値を設定
flog.info("--- %s.Rmd 実行終了、SEオブジェクトを返します ---", module_name)
return(se)
``` 