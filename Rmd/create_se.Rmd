---
title: "RNA-seq解析: SummarizedExperiment オブジェクト作成 (実験ID: `r params$experiment_id`)"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
params:
  experiment_id: "default_id"
  counts_file_path: ""
  metadata_file_path: ""
  gene_id_column: "gene_id"
  sample_id_column: "sample_id"
  biomart_host: "https://ensembl.org"
  biomart_dataset: ""
  biomart_attributes: !r c("ensembl_gene_id", "external_gene_name", "transcript_length", "gene_biotype")
  plot_output_dir: ""
---

```{r setup, include=FALSE}
# このチャンクはRmdファイルが読み込まれた時に最初に実行され、必要なパッケージの読み込みと設定を行う
library(futile.logger)
library(SummarizedExperiment)
library(biomaRt)
library(here)
library(fs)
library(ggplot2)
library(dplyr)
library(tibble)
library(readr)
library(tidyr)
library(knitr)
library(DT)

# utility関数を読み込む
source(here("R", "utility.R"))

# ログ設定
# utility.Rで定義したsetup_logger関数を使用
module_name <- "create_se"
logger_settings <- setup_logger(params$experiment_id, module_name)
flog.appender(logger_settings$appender)
flog.layout(logger_settings$layout)
flog.threshold(logger_settings$threshold)

# knitrオプションを設定 - メッセージと警告を表示
knitr::opts_chunk$set(
  message = FALSE, 
  warning = FALSE, 
  fig.width = 10,
  fig.height = 6,
  dpi = 300
)

# タイムスタンプの一貫性のためにタイムゾーンを統一
Sys.setenv(TZ = "Asia/Tokyo")

# グラフのテーマ設定
theme_set(theme_classic())

# 既存のオブジェクトをクリーンアップ
rm(list = setdiff(ls(), c("params")))

flog.info("--- セットアップ：R Markdownドキュメントを実行開始 ---")
flog.info("パラメータ情報: experiment_id = %s", params$experiment_id)
flog.info("セットアップ完了")
```

# はじめに

このレポートでは、RNA-seq解析パイプラインの最初のステップとして、カウントデータとサンプルメタデータから`SummarizedExperiment`オブジェクトを作成します。このオブジェクトは、後続の解析ステップで使用されるベースとなります。

## 処理の概要

以下の処理を実行します：

1. カウントデータとサンプルメタデータの読み込み
2. データの整合性チェック
3. biomaRtを使用した遺伝子アノテーション情報の取得
4. SummarizedExperimentオブジェクトの作成
5. メタデータの初期化と履歴記録

# 入力ファイルの読み込み

```{r check_input_files, include=FALSE}
flog.info("--- 入力ファイルの存在確認開始 ---")
# 入力ファイルの存在確認
if (!fs::file_exists(params$counts_file_path)) {
  msg <- sprintf("カウントファイルが見つかりません: %s", params$counts_file_path)
  flog.error(msg)
  stop(msg)
} else {
  flog.debug("カウントファイル確認OK: %s", params$counts_file_path)
}
if (!fs::file_exists(params$metadata_file_path)) {
  msg <- sprintf("メタデータファイルが見つかりません: %s", params$metadata_file_path)
  flog.error(msg)
  stop(msg)
} else {
  flog.debug("メタデータファイル確認OK: %s", params$metadata_file_path)
}
flog.info("--- 入力ファイルの存在確認完了 ---")
```

```{r read_input_files, include=FALSE}
flog.info("--- 入力ファイルの読み込み開始 ---")
# --- カウントデータの読み込み ---
flog.debug("カウントファイル読み込み中: %s", params$counts_file_path)
counts_data <- tryCatch(
  readr::read_csv(params$counts_file_path, show_col_types = FALSE, name_repair = "minimal"),
  error = function(e) {
    msg <- sprintf("カウントファイル '%s' の読み込みに失敗しました: %s", params$counts_file_path, e$message)
    flog.error(msg)
    stop(msg)
  }
)
flog.info("カウントファイルを正常に読み込みました。次元: %d 行 x %d 列", nrow(counts_data), ncol(counts_data))
flog.trace("カウントデータの列名: %s", paste(colnames(counts_data), collapse=", "))

# --- サンプルメタデータの読み込み ---
flog.debug("メタデータファイル読み込み中: %s", params$metadata_file_path)
sample_metadata <- tryCatch(
  readr::read_csv(params$metadata_file_path, show_col_types = FALSE, name_repair = "minimal"),
  error = function(e) {
    msg <- sprintf("メタデータファイル '%s' の読み込みに失敗しました: %s", params$metadata_file_path, e$message)
    flog.error(msg)
    stop(msg)
  }
)
flog.info("メタデータファイルを正常に読み込みました。次元: %d 行 x %d 列", nrow(sample_metadata), ncol(sample_metadata))
flog.trace("メタデータの列名: %s", paste(colnames(sample_metadata), collapse=", "))
flog.info("--- 入力ファイルの読み込み完了 ---")
```

## 入力データの概要

以下のファイルから入力データを読み込みました：

- **カウントデータ**: `r params$counts_file_path`
- **サンプルメタデータ**: `r params$metadata_file_path`

### カウントデータの概要

```{r count_data_summary}
# カウントデータの概要を表示
count_summary <- data.frame(
  "項目" = c("行数（遺伝子数）", "列数（サンプル数+遺伝子ID列）", "遺伝子ID列", "サンプル列 (一部)"),
  "値" = c(
    nrow(counts_data),
    ncol(counts_data),
    params$gene_id_column,
    paste(
        paste(setdiff(colnames(counts_data), params$gene_id_column)[1:min(5, ncol(counts_data)-1)], collapse=", "),
        if(ncol(counts_data) > (5 + 1)) "..." else "" # +1 for gene_id_column
    )
  )
)

kable(count_summary, caption = "カウントデータの基本情報")
```

### サンプルメタデータの概要

```{r metadata_summary}
# メタデータの概要を表示
meta_summary <- data.frame(
  "項目" = c("行数（サンプル数）", "列数（特性数）", "サンプルID列", "その他の列 (一部)"),
  "値" = c(
    nrow(sample_metadata),
    ncol(sample_metadata),
    params$sample_id_column,
    paste(
        paste(setdiff(colnames(sample_metadata), params$sample_id_column)[1:min(5, ncol(sample_metadata)-1)], collapse=", "),
        if(ncol(sample_metadata) > (5 + 1)) "..." else "" # +1 for sample_id_column
    )
  )
)

kable(meta_summary, caption = "サンプルメタデータの基本情報")
```

```{r peek_at_data, echo=FALSE}
# 最初の数行を表示
flog.trace("カウントデータの最初の10行を表示します。")
DT::datatable(head(counts_data, 10),
              caption = "カウントデータ（最初の10行）",
              options = list(scrollX = TRUE, pageLength = 5, dom = 'ftip'))

flog.trace("サンプルメタデータの最初の10行を表示します。")
DT::datatable(head(sample_metadata, 10),
              caption = "サンプルメタデータ（最初の10行）",
              options = list(scrollX = TRUE, pageLength = 5, dom = 'ftip'))
```

# データの整合性チェック

```{r data_check, include=FALSE}
flog.info("--- データの整合性チェック開始 ---")

# --- 必須列の存在確認 ---
flog.debug("必須列の存在を確認します。")
if (!params$gene_id_column %in% colnames(counts_data)) {
  msg <- sprintf("指定された遺伝子ID列 '%s' がカウントデータに存在しません。", params$gene_id_column)
  flog.error(msg)
  stop(msg)
}
if (!params$sample_id_column %in% colnames(sample_metadata)) {
  msg <- sprintf("指定されたサンプルID列 '%s' がメタデータに存在しません。", params$sample_id_column)
  flog.error(msg)
  stop(msg)
}
flog.debug("必須列の存在確認OK。")

# --- サンプルIDの一致確認 ---
flog.debug("カウントデータとメタデータのサンプルIDの一致を確認します。")
# カウントデータから遺伝子ID列を除いたサンプル列を取得
count_sample_ids <- setdiff(colnames(counts_data), params$gene_id_column)
flog.trace("カウントデータのサンプルID (n=%d): %s...", length(count_sample_ids), paste(head(count_sample_ids), collapse=", "))

# メタデータからサンプルID列を取得
meta_sample_ids <- sample_metadata[[params$sample_id_column]]
flog.trace("メタデータのサンプルID (n=%d): %s...", length(meta_sample_ids), paste(head(meta_sample_ids), collapse=", "))

# サンプルIDの一致確認
# all(count_sample_ids %in% meta_sample_ids) # メタデータに全て含まれるか
# all(meta_sample_ids %in% count_sample_ids) # カウントに全て含まれるか
# length(count_sample_ids) == length(meta_sample_ids) # 個数が同じか
if (setequal(count_sample_ids, meta_sample_ids)) {
  flog.info("サンプルIDはカウントヘッダーとメタデータ列 '%s' で完全に一致します (n=%d)。", params$sample_id_column, length(count_sample_ids))
} else {
  flog.warn("サンプルIDがカウントデータとメタデータ間で完全には一致しません。")
  missing_in_meta <- setdiff(count_sample_ids, meta_sample_ids)
  missing_in_counts <- setdiff(meta_sample_ids, count_sample_ids)

  if (length(missing_in_meta) > 0) {
    msg <- sprintf("メタデータに存在しないサンプルID (カウントには存在): %s",
                   paste(missing_in_meta, collapse=", "))
    flog.warn(msg)
    warning(msg) # 警告を出す
  }

  if (length(missing_in_counts) > 0) {
    msg <- sprintf("カウントデータに存在しないサンプルID (メタデータには存在): %s",
                   paste(missing_in_counts, collapse=", "))
    flog.warn(msg)
    warning(msg) # 警告を出す
  }
  # 処理は続行するが、後続のステップで問題になる可能性がある
}

# --- メタデータの並べ替え ---
# カウントデータのサンプル順にメタデータを並べ替える
# 注: ここでは count_sample_ids に存在するサンプルのみが対象となる
flog.debug("メタデータをカウントデータのサンプル順序 ('%s') に合わせて並べ替えます。", paste(count_sample_ids, collapse=", "))
sample_metadata_ordered <- sample_metadata[match(count_sample_ids, meta_sample_ids), ]
# match() は見つからない場合に NA 行を生成する可能性があるため、チェック
if(any(is.na(sample_metadata_ordered[[params$sample_id_column]]))) {
    na_rows <- which(is.na(sample_metadata_ordered[[params$sample_id_column]]))
    msg <- sprintf("メタデータの並べ替え中に問題が発生しました。カウントデータにあるがメタデータにないサンプルIDが存在します。NA行インデックス: %s", paste(na_rows, collapse=", "))
    flog.warn(msg)
    # エラーを警告に変更して処理を続行
    warning(msg)
    
    # NA行を除外する
    affected_samples <- count_sample_ids[is.na(sample_metadata_ordered[[params$sample_id_column]])]
    flog.warn("NA値を含む行をメタデータから除外します。影響を受けるサンプル: %s", 
             paste(affected_samples, collapse=", "))
    warning(sprintf("以下のサンプルはメタデータに存在しないため除外されます: %s", 
                  paste(affected_samples, collapse=", ")))
    valid_rows <- !is.na(sample_metadata_ordered[[params$sample_id_column]])
    sample_metadata_ordered <- sample_metadata_ordered[valid_rows, ]
    
    # カウントマトリックスも対応するサンプルに制限
    valid_samples <- count_sample_ids[valid_rows]
    flog.warn("カウントデータを有効なサンプル (%s) に制限します。", paste(valid_samples, collapse=", "))
    count_sample_ids <- valid_samples
}
flog.info("サンプルメタデータをカウントデータの列に合わせて並べ替えました。並べ替え後の次元: %d 行 x %d 列", nrow(sample_metadata_ordered), ncol(sample_metadata_ordered))
flog.trace("並べ替え後のメタデータサンプルID: %s...", paste(head(sample_metadata_ordered[[params$sample_id_column]]), collapse=", "))

flog.info("--- データの整合性チェック完了 ---")
```

# biomaRtによる遺伝子アノテーション取得

```{r biomart, include=FALSE}
flog.info("--- biomaRtによる遺伝子アノテーション取得開始 ---")

# --- 1. カウントデータからの遺伝子ID抽出と前処理 ---
flog.debug("カウントマトリックスの準備と遺伝子IDの抽出を行います。")
# カウントマトリックスとして抽出（指定された遺伝子ID列を行名、それ以外をカウントとして使用）
# 前の処理で count_sample_ids が更新されている可能性があるため、それを使用
count_matrix <- as.matrix(counts_data[, c(count_sample_ids)])
rownames(count_matrix) <- counts_data[[params$gene_id_column]]
flog.info("カウントマトリックスを準備しました。次元: %d 遺伝子, %d サンプル。", nrow(count_matrix), ncol(count_matrix))

# 遺伝子IDを取得（バージョン付きENSEMBLなど）
gene_ids_with_version <- rownames(count_matrix)
flog.info("カウントからのバージョン付き遺伝子IDの総数: %d", length(gene_ids_with_version))
flog.trace("バージョン付き遺伝子ID (一部): %s...", paste(head(gene_ids_with_version), collapse=", "))

# バージョン番号を削除（biomaRtクエリのため）- ENSEMBLの ".1", ".2" などを削除
# コメント: ENSEMBL ID は通常 ENSGXXXXXXXXXXX の形式で、バージョンは含まないことが多い。
# Gencode などでは ENSGXXXXXXXXXXX.Y の形式があるため、この処理は有効。
flog.debug("遺伝子IDからバージョン情報 (例: '.1', '.2') を削除します。")
gene_ids <- stringr::str_replace(gene_ids_with_version, "\\.[0-9]+$", "")
unique_gene_ids <- unique(gene_ids)
flog.info("バージョンを削除しました。biomaRtクエリ用の一意なバージョンなしID: %d 個。", length(unique_gene_ids))
flog.trace("バージョンなし一意遺伝子ID (一部): %s...", paste(head(unique_gene_ids), collapse=", "))

# --- 2. biomaRtに接続してアノテーション情報を取得 ---
flog.info("biomaRt ホスト '%s' のデータセット '%s' に接続します。", params$biomart_host, params$biomart_dataset)
# biomaRt接続
mart <- tryCatch(
  biomaRt::useMart(
    biomart = "ensembl",
    dataset = params$biomart_dataset,
    host = params$biomart_host
  ),
  error = function(e) {
    msg <- sprintf("biomaRt接続エラー (host: %s, dataset: %s): %s", params$biomart_host, params$biomart_dataset, e$message)
    flog.error(msg)
    stop(msg)
  }
)
flog.info("biomaRt に接続しました。")

# getBM に渡す属性リスト (パラメータから取得)
biomart_attrs_to_get <- params$biomart_attributes
# フィルタに使用する 'ensembl_gene_id' が属性リストに含まれているか確認
if (!"ensembl_gene_id" %in% biomart_attrs_to_get) {
    flog.warn("'ensembl_gene_id' が biomart_attributes に含まれていません。自動的に追加します。")
    biomart_attrs_to_get <- c("ensembl_gene_id", biomart_attrs_to_get)
}
flog.info("biomaRt で取得する属性: %s", paste(biomart_attrs_to_get, collapse=", "))

# アノテーション情報の取得
flog.info("biomaRt から %d 個の一意な遺伝子IDに対するアノテーションを取得中です...", length(unique_gene_ids))
annotation_raw <- tryCatch(
  biomaRt::getBM(
    attributes = biomart_attrs_to_get,
    filters = "ensembl_gene_id", # フィルタキーは固定
    values = unique_gene_ids,    # バージョンなしIDを使用
    mart = mart
  ),
  error = function(e) {
    msg <- sprintf("biomaRtからのアノテーション取得エラー (getBM): %s", e$message)
    flog.error(msg)
    # 停止させる。必要に応じてエラー時に空のデータフレームを返すなどの処理も可能。
    stop(msg)
  }
)

flog.info("biomaRt から %d 個のアノテーションレコードを正常に取得しました。", nrow(annotation_raw))
flog.trace("取得したアノテーションデータの列名: %s", paste(colnames(annotation_raw), collapse=", "))

# ensembl_gene_id（必須）がリストに含まれていない場合の処理 (useMart後のgetBMの結果には通常含まれるはずだが念のため)
if (!"ensembl_gene_id" %in% colnames(annotation_raw)) {
  msg <- sprintf("biomaRtからの取得結果に必須列 'ensembl_gene_id' がありません。取得属性: %s", paste(params$biomart_attributes, collapse=", "))
  flog.error(msg)
  stop(msg)
}

# 列名の標準化（biomaRt属性名をより一般的な名前に変更）
# external_gene_name → gene_name
# transcript_length → gene_length
# gene_biotype → gene_biotype （変更なし）
flog.debug("biomaRt 属性名を標準的な列名に変更します (例: external_gene_name -> gene_name)。")
col_mapping <- c(
  "external_gene_name" = "gene_name",
  "transcript_length" = "gene_length"
  # 他の標準化が必要な場合はここに追加
)

original_colnames <- colnames(annotation_raw)
colnames_changed <- FALSE
for (old_name in names(col_mapping)) {
  if (old_name %in% colnames(annotation_raw)) {
    new_name <- col_mapping[old_name]
    colnames(annotation_raw)[colnames(annotation_raw) == old_name] <- new_name
    flog.trace("列名を変更: '%s' -> '%s'", old_name, new_name)
    colnames_changed <- TRUE
  }
}
if (colnames_changed) {
    flog.debug("列名変更後のアノテーション列名: %s", paste(colnames(annotation_raw), collapse=", "))
} else {
    flog.debug("標準化対象の列名が見つからなかったため、列名は変更されませんでした。")
}


# --- 3. アノテーションデータの前処理 ---
flog.debug("取得したアノテーションデータの前処理を行います (重複削除、マッピング)。")
# 重複がある場合は処理（遺伝子IDごとに1行にする）
# getBM は通常、指定したIDに対してユニークな行を返すが、属性によっては1対多の関係がありうるため確認
duplicate_rows <- duplicated(annotation_raw$ensembl_gene_id)
if (any(duplicate_rows)) {
  num_duplicates <- sum(duplicate_rows)
  flog.warn("biomaRt 結果に %d 行の重複した ensembl_gene_id が見つかりました。最初の行を採用します。", num_duplicates)
  # 重複を削除（最初の行を保持）
  annotation_unique <- annotation_raw[!duplicate_rows, ]
  flog.info("重複を削除しました。一意なアノテーションレコード数: %d", nrow(annotation_unique))
} else {
  annotation_unique <- annotation_raw
  flog.debug("biomaRt 結果に ensembl_gene_id の重複はありませんでした。")
}

# 元のバージョン付き遺伝子IDに合わせたアノテーションデータを作成
# rowData の行名はカウントマトリックスの行名（バージョン付きID）と一致させる必要あり
flog.debug("元のバージョン付き遺伝子ID (%d 個) にアノテーション情報をマッピングします。", length(gene_ids_with_version))
# rowdata_df <- data.frame( ... ) # この定義は left_join の結果で上書きされるので不要かも

# 元のバージョン付き遺伝子IDに対応するバージョンなしのIDでアノテーションを検索し、マージする
# left_join を使うとより効率的
mapping_df <- data.frame(
    original_id = gene_ids_with_version,
    ensembl_gene_id = gene_ids # バージョンなしID (character)
)

# ★ 型変換: left_join 前に両方のキーを character に変換
flog.trace("結合キー 'ensembl_gene_id' の型を character に統一します。")
mapping_df$ensembl_gene_id <- as.character(mapping_df$ensembl_gene_id)
if ("ensembl_gene_id" %in% colnames(annotation_unique)) {
   annotation_unique$ensembl_gene_id <- as.character(annotation_unique$ensembl_gene_id)
   flog.trace("annotation_unique の ensembl_gene_id を character に変換しました。型: %s", 
              class(annotation_unique$ensembl_gene_id)[1])
} else {
    # ここには到達しないはずだが念のため
    msg <- "left_join 前のアノテーションデータに 'ensembl_gene_id' がありません。"
    flog.error(msg)
    stop(msg)
}

flog.trace("マッピング用データフレームの次元: %d行 x %d列", nrow(mapping_df), ncol(mapping_df))
flog.trace("アノテーションユニークデータの次元: %d行 x %d列", nrow(annotation_unique), ncol(annotation_unique))

# annotation_unique に ensembl_gene_id 列があることを確認済み
rowdata_merged <- dplyr::left_join(mapping_df, annotation_unique, by = "ensembl_gene_id")

# left_join 結果を確認
flog.trace("left_join 後の結果データフレームの次元: %d行 x %d列", nrow(rowdata_merged), ncol(rowdata_merged))
flog.trace("left_join 後の結果データフレームの列名: %s", paste(colnames(rowdata_merged), collapse=", "))

# 行名を元のバージョン付きIDに設定し、不要な列を削除
rownames(rowdata_merged) <- rowdata_merged$original_id
rowdata_df <- rowdata_merged[, !(colnames(rowdata_merged) %in% c("original_id"))] # ensembl_gene_id は残す

flog.trace("rowdata_df の最終次元: %d行 x %d列", nrow(rowdata_df), ncol(rowdata_df))
flog.trace("rowdata_df の列名: %s", paste(colnames(rowdata_df), collapse=", "))

# # オリジナルのループ実装 (参考)
# for (col in colnames(annotation_unique)) {
#   if (col != "ensembl_gene_id") { # ensembl_gene_id 自体はマッピング不要
#     # 初期化 (ベクトル化を考慮)
#     rowdata_df[[col]] <- NA_character_ # 型に合わせて NA を設定 (例: character)
#     # 型を合わせるためのより堅牢な方法が必要かもしれない
#     # 例: rowdata_df[[col]] <- vector(mode(annotation_unique[[col]]), length = nrow(rowdata_df))
#
#     # バージョンなしIDとアノテーションのマッピング
#     # match を使うと高速化できる
#     matched_indices <- match(gene_ids, annotation_unique$ensembl_gene_id)
#     # NA でないマッチ結果に対応するアノテーションを設定
#     valid_matches <- !is.na(matched_indices)
#     rowdata_df[valid_matches, col] <- annotation_unique[matched_indices[valid_matches], col]
#   }
# }
# # アノテーションデータに "ensembl_gene_id" 列を追加（バージョンなし）
# rowdata_df$ensembl_gene_id <- gene_ids

flog.info("アノテーションのマッピング完了。rowData の次元: %d 行, %d 列。", nrow(rowdata_df), ncol(rowdata_df))

# NAチェック
na_counts <- sapply(rowdata_df, function(x) sum(is.na(x)))
na_summary <- na_counts[na_counts > 0]
if (length(na_summary) > 0) {
  flog.warn("biomaRt アノテーションで NA が含まれる列があります:")
  for(colname in names(na_summary)){
      flog.warn("- 列 '%s': %d 個の NA (全 %d 行中)", colname, na_summary[colname], nrow(rowdata_df))
  }
} else {
  flog.info("biomaRt アノテーション結果に NA はありませんでした。")
}


# rowData用のDataFrameに変換 (S4Vectors)
# DataFrame は NULL を許容しないため、NA に注意
flog.debug("rowData を S4Vectors::DataFrame に変換します。")
rowdata <- tryCatch(
    DataFrame(rowdata_df, row.names = rownames(rowdata_df)), # 行名を明示的に指定
    error = function(e){
        msg <- sprintf("rowData の DataFrame への変換に失敗しました: %s", e$message)
        flog.error(msg)
        flog.error("rowdata_df の内容:")
        flog.error(capture.output(str(rowdata_df)))
        stop(msg)
    }
)

flog.info("アノテーションを rowData 用の DataFrame にフォーマットしました。次元: %d 行, %d 列。",
          nrow(rowdata), ncol(rowdata))
flog.trace("rowData (DataFrame) の列名: %s", paste(colnames(rowdata), collapse=", "))

# 行名一致確認 (SummarizedExperiment 作成前の最終チェック)
if (!identical(rownames(count_matrix), rownames(rowdata))) {
  msg <- "最終チェック: カウントマトリックスと rowData の行名が一致しません。"
  flog.error(msg)
  flog.error("カウントマトリックス行名 (先頭): %s", paste(head(rownames(count_matrix)), collapse=", "))
  flog.error("rowData 行名 (先頭): %s", paste(head(rownames(rowdata)), collapse=", "))
  stop(msg)
} else {
    flog.debug("最終チェック: カウントマトリックスと rowData の行名は一致します。")
}
flog.info("--- biomaRtによる遺伝子アノテーション取得完了 ---")

```

# SummarizedExperiment オブジェクトの作成

```{r create_se, include=FALSE}
flog.info("--- SummarizedExperiment オブジェクト作成開始 ---")
# --- SummarizedExperiment オブジェクト作成 ---
# count_matrix, sample_metadata_ordered, rowdata の準備は完了済み
flog.debug("SummarizedExperiment オブジェクトを作成します。入力データサイズ: (counts: %d x %d, colData: %d x %d, rowData: %d x %d)",
          nrow(count_matrix), ncol(count_matrix),
          nrow(sample_metadata_ordered), ncol(sample_metadata_ordered),
          nrow(rowdata), ncol(rowdata))

# colData用のDataFrameを準備
flog.trace("colData用のDataFrameを準備します。サンプルID列名: %s", params$sample_id_column)
col_data_df <- DataFrame(sample_metadata_ordered)
# 行名を明示的に設定
rownames(col_data_df) <- sample_metadata_ordered[[params$sample_id_column]]
flog.trace("colData用のDataFrameの行名を設定しました: %s", paste(head(rownames(col_data_df)), collapse=", "))

se <- tryCatch(
    SummarizedExperiment(
      assays = list(counts = count_matrix),
      colData = col_data_df, # 事前に行名を設定済みのDataFrame
      rowData = rowdata # rowData はすでに行名が設定されているはず
    ),
    error = function(e){
        msg <- sprintf("SummarizedExperiment オブジェクトの作成に失敗しました: %s", e$message)
        flog.error(msg)
        flog.error("入力データの次元:")
        flog.error("- assays$counts: %d x %d", nrow(count_matrix), ncol(count_matrix))
        flog.error("- colData: %d x %d", nrow(col_data_df), ncol(col_data_df))
        flog.error("- rowData: %d x %d", nrow(rowdata), ncol(rowdata))
        stop(msg)
    }
)

flog.info("SummarizedExperiment オブジェクトを正常に作成しました。")
flog.debug("SE オブジェクトのクラス: %s", paste(class(se), collapse=", "))
flog.debug("SE オブジェクトの次元: %d features, %d samples", nrow(se), ncol(se))
flog.debug("SE assay 名: %s", paste(assayNames(se), collapse=", "))
flog.debug("SE colData 列名: %s", paste(colnames(colData(se)), collapse=", "))
flog.debug("SE rowData 列名: %s", paste(colnames(rowData(se)), collapse=", "))


# --- メタデータの初期化と履歴記録 ---
flog.info("SE オブジェクトのメタデータに実験情報とパイプライン履歴を記録します。")
# 実験IDを記録
metadata(se)$experiment_id <- params$experiment_id

# utility関数を使用してパイプライン履歴を記録
se <- record_pipeline_history(
  se = se,
  module_name = "create_se",
  description = "SummarizedExperiment オブジェクト作成",
  parameters = list(
    experiment_id = params$experiment_id,
    counts_file_path = params$counts_file_path,
    metadata_file_path = params$metadata_file_path,
    gene_id_column = params$gene_id_column,
    sample_id_column = params$sample_id_column,
    biomart_host = params$biomart_host,
    biomart_dataset = params$biomart_dataset,
    biomart_attributes = params$biomart_attributes
  )
)

flog.info("SE メタデータに pipeline_history['create_se'] を記録しました。")
flog.info("--- SummarizedExperiment オブジェクト作成完了 ---")
flog.info("実験 '%s' の SummarizedExperiment オブジェクト作成プロセスが正常に完了しました。", params$experiment_id)
```

## SummarizedExperiment オブジェクトの概要

```{r se_summary}
# SEオブジェクトの基本情報表示
se_summary_df <- data.frame(
  "項目" = c("クラス", "サンプル数 (ncol)", "遺伝子数/フィーチャー数 (nrow)", "Assay名", "colData列数", "colData列名", "rowData列数", "rowData列名", "メタデータ項目"),
  "値" = c(
    paste(class(se), collapse=", "),
    ncol(se),
    nrow(se),
    paste(assayNames(se), collapse=", "),
    ncol(colData(se)),
    paste(colnames(colData(se)), collapse=", "),
    ncol(rowData(se)),
    paste(colnames(rowData(se)), collapse=", "),
    paste(names(metadata(se)), collapse=", ")
  )
)

kable(se_summary_df, caption = "作成された SummarizedExperiment オブジェクトの概要")
```

## SEオブジェクトの内容確認

```{r show_se_details}
# assaysの一部表示 (カウント行列の一部)
flog.debug("assaysの一部を表示します")
assay_preview <- as.data.frame(head(assay(se, "counts"), 10))
DT::datatable(assay_preview,
              caption = "assay(\"counts\") の最初の10行",
              options = list(scrollX = TRUE, pageLength = 5, dom = 'ftip'))

# colDataのプレビュー
flog.debug("colDataの一部を表示します")
DT::datatable(as.data.frame(colData(se)),
              caption = "colData (サンプルメタデータ)",
              options = list(scrollX = TRUE, pageLength = ncol(se), dom = 'fti'))

# rowDataのプレビュー
flog.debug("rowDataの一部を表示します")
DT::datatable(head(as.data.frame(rowData(se)), 20),
              caption = "rowData (最初の20行)",
              options = list(scrollX = TRUE, pageLength = 10, dom = 'ftip'))
```

## 遺伝子タイプ (gene_biotype) の分布

```{r gene_biotype_distribution}
flog.info("gene_biotypeの分布を集計・可視化します")

# gene_biotypeの存在確認
if (!"gene_biotype" %in% colnames(rowData(se))) {
  flog.warn("rowDataに'gene_biotype'列が存在しません")
  # gene_biotype列がない場合はメッセージを表示
  cat("rowDataに'gene_biotype'列が存在しないため、分布を表示できません。\n")
} else {
  # gene_biotypeの分布を集計
  gene_biotype_counts <- table(rowData(se)$gene_biotype)
  
  # テーブルが空かどうかチェック
  if (length(gene_biotype_counts) == 0) {
    flog.warn("gene_biotypeのカウントが0件です")
    cat("gene_biotypeのカウントが0件のため、分布を表示できません。\n")
  } else {
    gene_biotype_df <- data.frame(
      biotype = names(gene_biotype_counts),
      count = as.numeric(gene_biotype_counts)
    )
    
    # 件数が多い順にソート
    gene_biotype_df <- gene_biotype_df[order(gene_biotype_df$count, decreasing = TRUE), ]
    
    # 上位10個のbiotype + その他を表示
    if (nrow(gene_biotype_df) > 10) {
      flog.debug("gene_biotypeは10種類以上あるため、上位10種類のみをプロットし、残りは'その他'として集計します")
      other_count <- sum(gene_biotype_df$count[11:nrow(gene_biotype_df)])
      gene_biotype_plot_df <- rbind(
        gene_biotype_df[1:10, ],
        data.frame(biotype = "その他", count = other_count)
      )
    } else {
      gene_biotype_plot_df <- gene_biotype_df
    }
    
    # テーブル表示
    kable(gene_biotype_df, caption = "遺伝子タイプ (gene_biotype) の分布")
    
    # バープロット作成
    flog.debug("gene_biotypeの分布をバープロットで可視化します")
    ggplot(gene_biotype_plot_df, aes(x = reorder(biotype, -count), y = count)) +
      geom_bar(stat = "identity", fill = "steelblue") +
      theme_classic() +
      labs(
        title = "遺伝子タイプ (gene_biotype) の分布",
        x = "Gene Biotype",
        y = "Count"
      ) +
      theme(
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1)
      )
  }
}
```

## protein_coding遺伝子の詳細分析

```{r protein_coding_analysis}
flog.info("protein_coding遺伝子に関する詳細分析を行います")

# gene_biotypeの存在確認
if (!"gene_biotype" %in% colnames(rowData(se))) {
  flog.warn("rowDataに'gene_biotype'列が存在しません")
  cat("rowDataに'gene_biotype'列が存在しないため、protein_coding遺伝子の分析ができません。\n")
} else {
  # gene_biotypeが空かどうか確認
  if (all(is.na(rowData(se)$gene_biotype)) || length(unique(rowData(se)$gene_biotype)) == 0) {
    flog.warn("gene_biotypeの値がすべてNAまたは空です")
    cat("gene_biotypeの値がすべてNAまたは空のため、protein_coding遺伝子の分析ができません。\n")
  } else {
    # protein_coding遺伝子の抽出
    is_protein_coding <- rowData(se)$gene_biotype == "protein_coding"
    
    # NA値をFALSEに変換
    is_protein_coding[is.na(is_protein_coding)] <- FALSE
    
    # protein_coding遺伝子の数をカウント
    protein_coding_count <- sum(is_protein_coding, na.rm = TRUE)
    total_genes <- nrow(se)
    protein_coding_percentage <- round(protein_coding_count / total_genes * 100, 2)
    
    flog.info("protein_coding遺伝子数: %d / %d 遺伝子 (%.2f%%)", 
              protein_coding_count, total_genes, protein_coding_percentage)
    
    # 結果表示
    protein_coding_summary <- data.frame(
      "項目" = c("protein_coding遺伝子数", "総遺伝子数", "protein_coding遺伝子の割合"),
      "値" = c(
        protein_coding_count,
        total_genes,
        paste0(protein_coding_percentage, "%")
      )
    )
    
    kable(protein_coding_summary, caption = "protein_coding遺伝子の統計")
    
    # protein_codingが0件の場合は分析終了
    if (protein_coding_count == 0) {
      flog.warn("protein_coding遺伝子が0件のため、詳細分析は行いません")
      cat("protein_coding遺伝子が0件のため、詳細分析は行いません。\n")
    } else {
      # パラメータの欠損チェック
      flog.debug("protein_coding遺伝子のアノテーション欠損状況を確認します")
      
      # protein_coding遺伝子のみのrowDataを抽出
      protein_coding_rowdata <- rowData(se)[is_protein_coding, ]
      
      # 各列の欠損値カウント
      if (ncol(protein_coding_rowdata) > 0) {
        na_counts <- sapply(as.data.frame(protein_coding_rowdata), function(x) sum(is.na(x)))
        na_percentages <- round(na_counts / nrow(protein_coding_rowdata) * 100, 2)
        
        # 欠損値のあるパラメータのみ表示
        na_summary <- data.frame(
          "パラメータ" = names(na_counts),
          "欠損数" = na_counts,
          "欠損率(%)" = na_percentages
        )
        
        if (any(na_counts > 0)) {
          flog.warn("protein_coding遺伝子のアノテーションに欠損があります")
          na_summary_nonzero <- na_summary[na_counts > 0, ]
          kable(na_summary_nonzero, caption = "protein_coding遺伝子のアノテーション欠損状況")
        } else {
          flog.info("protein_coding遺伝子のアノテーションに欠損はありません")
          cat("protein_coding遺伝子のアノテーションに欠損はありません。\n")
        }
      }
    }
  }
}
```

## サンプルごとのprotein_coding遺伝子のライブラリサイズ比較

```{r protein_coding_library_size, include=FALSE}
flog.info("サンプルごとのprotein_coding遺伝子のライブラリサイズを比較します")

# 発現量分布の可視化関数
plot_protein_coding_library_size <- function(se) {
  flog.info("--- plot_protein_coding_library_size 関数を実行します ---")
  
  # gene_biotypeの存在確認
  if (!"gene_biotype" %in% colnames(rowData(se))) {
    flog.warn("rowDataに'gene_biotype'列が存在しません")
    return(NULL)
  }
  
  # gene_biotypeが空かどうか確認
  if (all(is.na(rowData(se)$gene_biotype)) || length(unique(rowData(se)$gene_biotype)) == 0) {
    flog.warn("gene_biotypeの値がすべてNAまたは空です")
    return(NULL)
  }
  
  # protein_coding遺伝子の抽出
  is_protein_coding <- rowData(se)$gene_biotype == "protein_coding"
  
  # NA値をFALSEに変換
  is_protein_coding[is.na(is_protein_coding)] <- FALSE
  
  # protein_coding遺伝子が0件の場合は分析終了
  if (sum(is_protein_coding) == 0) {
    flog.warn("protein_coding遺伝子が0件のため、ライブラリサイズ比較は行いません")
    return(NULL)
  }
  
  # protein_coding遺伝子のみのカウントを取得
  protein_coding_counts <- assay(se, "counts")[is_protein_coding, , drop = FALSE]
  
  # サンプルごとの合計カウントを計算
  library_sizes <- colSums(protein_coding_counts)
  
  # データフレームに変換（プロット用）
  library_size_df <- data.frame(
    sample_id = names(library_sizes),
    library_size = library_sizes
  )
  
  # ソート
  library_size_df <- library_size_df[order(library_size_df$library_size, decreasing = TRUE), ]
  
  # バープロット作成
  flog.debug("サンプルごとのprotein_coding遺伝子のライブラリサイズをバープロットで可視化します")
  p <- ggplot(library_size_df, aes(x = reorder(sample_id, -library_size), y = library_size)) +
    geom_bar(stat = "identity", fill = "darkgreen") +
    theme_classic() +
    labs(
      title = "サンプルごとのprotein_coding遺伝子のライブラリサイズ",
      x = "Sample ID",
      y = "Library Size (protein_coding genes only)"
    ) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
  
  flog.info("--- plot_protein_coding_library_size 関数の実行完了 ---")
  return(p)
}

# gene_biotypeの存在確認
if (!"gene_biotype" %in% colnames(rowData(se))) {
  flog.warn("rowDataに'gene_biotype'列が存在しません")
  protein_coding_plot <- NULL
  library_size_df <- NULL
  library_sizes <- NULL
} else {
  # gene_biotypeが空かどうか確認
  if (all(is.na(rowData(se)$gene_biotype)) || length(unique(rowData(se)$gene_biotype)) == 0) {
    flog.warn("gene_biotypeの値がすべてNAまたは空です")
    protein_coding_plot <- NULL
    library_size_df <- NULL
    library_sizes <- NULL
  } else {
    # protein_coding遺伝子の抽出
    is_protein_coding <- rowData(se)$gene_biotype == "protein_coding"
    
    # NA値をFALSEに変換
    is_protein_coding[is.na(is_protein_coding)] <- FALSE
    
    # protein_coding遺伝子が0件の場合は分析終了
    if (sum(is_protein_coding) == 0) {
      flog.warn("protein_coding遺伝子が0件のため、ライブラリサイズ比較は行いません")
      protein_coding_plot <- NULL
      library_size_df <- NULL
      library_sizes <- NULL
    } else {
      # protein_coding遺伝子のみのカウントを取得
      protein_coding_counts <- assay(se, "counts")[is_protein_coding, , drop = FALSE]
      
      # サンプルごとの合計カウントを計算
      library_sizes <- colSums(protein_coding_counts)
      
      # データフレームに変換（プロット用）
      library_size_df <- data.frame(
        sample_id = names(library_sizes),
        library_size = library_sizes
      )
      
      # ソート
      library_size_df <- library_size_df[order(library_size_df$library_size, decreasing = TRUE), ]
      
      # プロット作成
      protein_coding_plot <- plot_protein_coding_library_size(se)
    }
  }
}
```

```{r display_protein_coding_library_size}
# gene_biotypeの存在確認
if (!"gene_biotype" %in% colnames(rowData(se))) {
  cat("rowDataに'gene_biotype'列が存在しないため、protein_coding遺伝子のライブラリサイズ比較ができません。\n")
} else {
  # gene_biotypeが空かどうか確認
  if (all(is.na(rowData(se)$gene_biotype)) || length(unique(rowData(se)$gene_biotype)) == 0) {
    cat("gene_biotypeの値がすべてNAまたは空のため、protein_coding遺伝子のライブラリサイズ比較ができません。\n")
  } else {
    # protein_coding遺伝子の有無を確認
    if (!exists("library_size_df") || is.null(library_size_df)) {
      cat("protein_coding遺伝子が0件のため、ライブラリサイズ比較は行いません。\n")
    } else {
      # バープロットを表示
      if (!is.null(protein_coding_plot)) {
        print(protein_coding_plot)
      }
      
      # 表形式でも表示
      kable(library_size_df, caption = "サンプルごとのprotein_coding遺伝子のライブラリサイズ")
      
      # 統計情報
      if (exists("library_sizes") && !is.null(library_sizes)) {
        library_size_stats <- data.frame(
          "統計量" = c("最小値", "第1四分位", "中央値", "平均", "第3四分位", "最大値", "標準偏差", "変動係数(%)"),
          "値" = c(
            min(library_sizes),
            quantile(library_sizes, 0.25),
            median(library_sizes),
            mean(library_sizes),
            quantile(library_sizes, 0.75),
            max(library_sizes),
            sd(library_sizes),
            round(sd(library_sizes) / mean(library_sizes) * 100, 2)
          )
        )
        
        kable(library_size_stats, caption = "protein_coding遺伝子のライブラリサイズの統計情報")
      }
    }
  }
}
```

## サンプル間の発現量分布比較

サンプル間の発現量パターンを比較し、データの品質とばらつきを評価します。これによりバッチ効果や外れ値サンプルの初期判定が可能になります。

```{r define_plot_functions, include=FALSE}
# 発現量分布の可視化関数
plot_expression_density <- function(se, log_transform = TRUE, pseudo_count = 1, 
                                    assay_name = "counts", adjust = 1.5, 
                                    remove_outliers = TRUE, outlier_quantile = 0.99) {
  flog.info("--- plot_expression_density 関数を実行します ---")
  
  # パラメータのロギング
  flog.debug("パラメータ: log_transform=%s, pseudo_count=%f, assay_name=%s, adjust=%f", 
             log_transform, pseudo_count, assay_name, adjust)
  
  # カウント行列の取得
  if (!assay_name %in% assayNames(se)) {
    msg <- sprintf("指定されたassay '%s' がSEオブジェクトに存在しません", assay_name)
    flog.error(msg)
    stop(msg)
  }
  
  counts_matrix <- assay(se, assay_name)
  flog.debug("カウント行列の次元: %d x %d", nrow(counts_matrix), ncol(counts_matrix))
  
  # ロング形式に変換
  counts_long <- data.frame()
  
  for (sample_id in colnames(counts_matrix)) {
    sample_counts <- counts_matrix[, sample_id]
    
    # log変換の場合、0を除外（Infinityを避けるため）
    if (log_transform) {
      non_zero_count <- sum(sample_counts > 0)
      flog.trace("サンプル %s の非ゼロカウント数: %d (全 %d 中)", 
                sample_id, non_zero_count, length(sample_counts))
      
      sample_counts <- sample_counts[sample_counts > 0]
      # log2変換
      sample_counts <- log2(sample_counts + pseudo_count)
      value_label <- "log2(count + 1)"
    } else {
      # 生データでは0を保持
      value_label <- "count"
    }
    
    # データフレームに追加
    sample_df <- data.frame(
      sample_id = sample_id,
      value = sample_counts
    )
    
    counts_long <- rbind(counts_long, sample_df)
  }
  
  flog.debug("ロング形式データの次元: %d x %d", nrow(counts_long), ncol(counts_long))
  
  # 外れ値の除外（生データの場合のみ）
  xlim_params <- list()
  if (!log_transform && remove_outliers) {
    upper_limit <- quantile(counts_long$value, outlier_quantile)
    flog.debug("外れ値除外のための上限値: %f (%g %%)", upper_limit, outlier_quantile * 100)
    xlim_params <- list(xlim = c(0, upper_limit))
  }
  
  # プロット作成
  plot_title <- sprintf("サンプル間の発現量分布比較 (%s)", 
                       ifelse(log_transform, "log2変換", "生データ"))
  
  p <- ggplot(counts_long, aes(x = value, color = sample_id)) +
    geom_density(adjust = adjust) +
    theme_classic() +
    labs(
      title = plot_title,
      x = value_label,
      y = "Density"
    ) +
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "right",
      legend.title = element_blank()
    )
  
  # 外れ値除外パラメータの適用
  if (length(xlim_params) > 0) {
    p <- p + do.call(xlim, xlim_params)
  }
  
  flog.info("--- plot_expression_density 関数の実行完了 ---")
  return(p)
}
```

```{r expression_density_plots, fig.height=8}
flog.info("--- サンプル間の発現量分布を比較します ---")

# 1. 生データでの分布比較
flog.debug("生データの発現量分布プロットを作成します")
p1 <- plot_expression_density(se, log_transform = FALSE)

# 2. log2変換データでの分布比較
flog.debug("log2変換後の発現量分布プロットを作成します")
p2 <- plot_expression_density(se, log_transform = TRUE)

# カウント行列の取得（追加の統計情報用）
counts_matrix <- assay(se, "counts")

# 分布の統計情報
flog.debug("サンプルごとの発現量分布の統計情報を計算します")
expression_stats <- data.frame(
  sample_id = colnames(counts_matrix),
  mean_raw = colMeans(counts_matrix),
  median_raw = apply(counts_matrix, 2, median),
  non_zero_genes = colSums(counts_matrix > 0),
  percent_non_zero = round(colSums(counts_matrix > 0) / nrow(counts_matrix) * 100, 2)
)

# 統計情報を表示
kable(expression_stats, caption = "サンプルごとの発現量分布の統計情報")

# プロットを表示
print(p1)
print(p2)

# 分布の解釈
cat("### 発現量分布の解釈\n\n")
cat("- 理想的には、全サンプルの分布形状が類似しており、大きなばらつきがないことが望ましいです。\n")
cat("- 特定のサンプルだけが他と大きく異なる分布を示す場合、実験的な問題やバッチ効果の可能性があります。\n")
cat("- log2変換後の分布は通常、より正規分布に近くなり、サンプル間の比較が容易になります。\n")
cat("- 非ゼロ遺伝子の割合が著しく低いサンプルは、シーケンシング深度や品質に問題がある可能性があります。\n")

flog.info("--- サンプル間の発現量分布比較完了 ---")
```

# セッション情報

```{r session_info}
# セッション情報の表示（パイプラインの再現性のため）
flog.info("--- セッション情報を記録します ---")
sessionInfo()
```

```{r return_se, echo=FALSE, include=FALSE}
# targetsパッケージで使用するための戻り値を設定
flog.info("--- create_se.Rmd 実行終了、SEオブジェクトを返します ---")
return(se)
``` 